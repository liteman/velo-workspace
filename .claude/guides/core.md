# Velociraptor Core Reference — Shared VQL and Artifact Schema

> This guide covers content shared across all platforms. Platform-specific VQL functions,
> accessors, paths, and patterns are in the overlay guides (windows.md, macos.md, linux.md,
> server.md). Overlays assume this file is loaded.

---

## 1. YAML Artifact Schema

Every Velociraptor artifact is a YAML file. The full field reference:

```yaml
name: Platform.Category.ArtifactName   # REQUIRED. Dotted CamelCase. Must match file path.
description: |                          # REQUIRED. Markdown supported.
  One-line summary of what this artifact does.

  Longer explanation, usage notes, caveats.

  ## NOTES
  - Bullet points for important details.

type: CLIENT                            # Optional. Default CLIENT.
                                        # Options: CLIENT, SERVER, CLIENT_EVENT,
                                        #          SERVER_EVENT, INTERNAL, NOTEBOOK

author: First Last - @handle            # Optional. Free-form string.

reference:                              # Optional. List of URLs.
  - https://example.com/relevant-page

aliases:                                # Optional. Alternative artifact names.
  - Platform.OldName.Compat

imports:                                # Optional. Load export blocks from these artifacts.
  - Windows.Sys.AllUsers

precondition: |                         # Optional. If returns 0 rows, artifact is skipped.
  SELECT OS FROM info() WHERE OS =~ 'windows'

parameters:                             # Optional. User-configurable inputs.
  - name: ParamName                     # REQUIRED per param. CamelCase.
    description: What this controls     # Optional but recommended.
    type: string                        # Optional. Default "string". See Section 3.
    default: some_value                 # Optional but strongly recommended.

required_permissions:                   # Optional. Permissions the operator must have.
  - EXECVE

implied_permissions:                    # Optional. Permissions granted on the client.
  - FILESYSTEM_WRITE

tools:                                  # Optional. External binaries to fetch.
  - name: ToolName
    github_project: Org/Repo
    github_asset_regex: linux-amd64
    serve_locally: true
    expected_hash: abc123...            # Optional SHA256 for verification

resources:                              # Optional. Resource limits.
  timeout: 600                          # Seconds.
  ops_per_second: 20                    # Rate limiting for expensive operations.

export: |                               # Optional. VQL available to importing artifacts.
  LET SharedFunction(X) = ...           # Does NOT run during this artifact's collection.

sources:                                # REQUIRED. One or more query sources.
  - name: SourceName                    # Optional. Unnamed = default source.
    precondition: |                     # Optional. Source-level precondition.
      SELECT OS FROM info() WHERE OS =~ 'windows'
    query: |                            # REQUIRED. The VQL query.
      SELECT * FROM glob(globs=SomeGlob)

column_types:                           # Optional. Controls GUI rendering of columns.
  - name: ColumnName
    type: timestamp                     # See Section 7.
```

### Schema Notes

- Only `name`, `description`, and `sources[].query` are truly required.
- If **any** source has a `precondition`, all sources run in **parallel** (independent scopes). Without source-level preconditions, sources run **serially** (shared scope).
- The `export` block makes VQL available to other artifacts but does NOT run during collection — it only provides reusable definitions.
- `type: CLIENT` is the default; always declare `type:` explicitly for SERVER, CLIENT_EVENT, and SERVER_EVENT artifacts.

### Artifact Types

| Type | Purpose | Where it runs |
|------|---------|--------------|
| `CLIENT` | One-time on-demand collection | On the endpoint |
| `CLIENT_EVENT` | Continuous monitoring (never terminates) | On the endpoint |
| `SERVER` | One-time server-side operation | On the server |
| `SERVER_EVENT` | Continuous server-side monitoring | On the server |
| `INTERNAL` | System event stream definition (rarely authored) | Framework |
| `NOTEBOOK` | Typically auto-generated by UI | Analysis notebooks |

**CLIENT_EVENT authoring rule:** The query must **never terminate** — it must block forever waiting for events. Use a `watch_*` plugin as the event source (e.g., `watch_evtx()`, `watch_etw()`, `watch_ebpf()`, `watch_journald()`, `watch_usn()`). Do not use regular polling plugins like `glob()` or `read_file()` as the primary source; those will cause the artifact to exit after one pass.

```sql
-- Correct: watch_evtx blocks until the artifact is cancelled
SELECT * FROM watch_evtx(filename=EventLogPath)
WHERE System.EventID.Value = 4688

-- Wrong: glob() terminates after listing files — do not use as sole source in CLIENT_EVENT
SELECT * FROM glob(globs=SearchGlob)
```

### Naming Convention

Format: `Platform.Category.ArtifactName` or `Platform.Category.Subcategory.Name`

- Use **CamelCase** for each segment.
- Only alphanumeric characters and `.` in the artifact name (no dashes, spaces, or underscores).
- Parameter names use CamelCase: `SearchFilesGlob`, `DateAfter`, `Upload_File`.
- The artifact name must match its file path: `Windows.Sys.Users` → `Windows/Sys/Users.yaml`.

### Multi-Source Artifacts

```yaml
sources:
  - name: FirstSource
    query: |
      SELECT * FROM plugin_a()

  - name: SecondSource
    query: |
      SELECT * FROM plugin_b()
```

Named sources run **serially** with shared scope unless source-level preconditions are added (which triggers parallel execution with independent scopes).

---

## 2. Precondition Patterns

### Standard Forms

```yaml
# Form 1: Regex match (PREFERRED — handles case variations)
precondition: SELECT OS FROM info() WHERE OS =~ 'windows'

# Form 2: Exact match
precondition: SELECT OS From info() where OS = 'linux'

# Form 3: SELECT * (used by some older artifacts)
precondition: SELECT * FROM info() where OS = 'darwin'

# Form 4: Combined / cross-platform
precondition: SELECT OS From info() where OS = 'linux' OR OS = 'darwin'

# Form 5: With additional checks (architecture, function version)
precondition: |
  SELECT OS FROM info()
  WHERE OS = 'windows'
    AND Architecture = "amd64"
```

**Recommendation:** Use Form 1 (`OS =~ 'platform'`) for new artifacts. It is the most robust.

### Artifact-Level vs Source-Level

- Put the precondition at the **artifact level** unless sources need independent OS checks.
- **Warning:** Source-level preconditions trigger parallel execution. Sources cannot share `LET` variables across sources in parallel mode.

### Server Artifacts

Server artifacts have **no OS precondition** — the server is always the execution context. See server.md for credential-check patterns used instead.

---

## 3. Parameter Types

All parameter types observed across artifacts:

### string (default)

Most common. Used for file paths, glob patterns, SQL queries, registry keys.

```yaml
- name: SearchGlob
  default: /path/to/target/**,/data/**
  description: Comma-separated glob patterns to search.
```

Consumed in VQL: `FROM glob(globs=split(string=SearchGlob, sep=","))`

### bool

Boolean toggle. **Default must be `Y` or `N` — never `true`/`false`.**

```yaml
- name: Upload_File
  type: bool
  default: N
  description: Upload matching files to the server.
```

Consumed in VQL: `if(condition=Upload_File, then=upload(file=OSPath))`

### regex

Regular expression for filtering. Default `.` matches everything (optional filter).

```yaml
- name: PathRegex
  type: regex
  default: .
  description: Regex filter applied to file paths.
```

Consumed in VQL: `WHERE OSPath =~ PathRegex`

### timestamp

ISO 8601 timestamp for date filtering. Empty string default means "no filter".

```yaml
- name: DateAfter
  type: timestamp
  description: "Search for events after this date. YYYY-MM-DDTmm:hh:ssZ"

- name: DateBefore
  type: timestamp
  description: "Search for events before this date. YYYY-MM-DDTmm:hh:ssZ"
```

Consumed in VQL with sentinel values:
```sql
LET DateAfterTime <= if(condition=DateAfter,
  then=DateAfter, else=timestamp(epoch="1600-01-01"))
LET DateBeforeTime <= if(condition=DateBefore,
  then=DateBefore, else=timestamp(epoch="2200-01-01"))
WHERE EventTime > DateAfterTime AND EventTime < DateBeforeTime
```

### int / integer / int64

Integer values. Use `int64` for large values (file sizes, byte offsets).

```yaml
- name: SizeMax
  type: int64
  default: 4294967296
  description: Maximum file size in bytes.

- name: Period
  type: int
  default: 60
  description: Monitoring period in seconds.
```

### csv

Table of values. The default is pipe-delimited CSV with a header row.

```yaml
- name: SearchFilesGlobTable
  type: csv
  default: |
    Glob
    /path/to/target/*
    /data/**
```

Consumed in VQL: `FROM glob(globs=SearchFilesGlobTable.Glob)` — access columns by header name.

### yara

YARA rule text. Default is typically empty or contains a sample rule.

```yaml
- name: YaraRule
  type: yara
  default:
  description: A YARA rule to search for matching files.
```

Consumed in VQL: `FROM yara(files=OSPath, key="A", rules=YaraRule, accessor="file")`

### choices

Dropdown selection from a fixed list.

```yaml
- name: Accessor
  type: choices
  default: auto
  choices:
    - auto
    - file
    - ntfs
  description: Which file accessor to use.
```

Consumed in VQL: Direct reference by name: `FROM glob(globs=Glob, accessor=Accessor)`

### glob

A string typed as a glob pattern (single or comma-separated).

```yaml
- name: JournalGlob
  type: glob
  default: /{run,var}/log/journal/*/*.journal
  description: Glob pattern for journal files.
```

### hidden

Parameters hidden from the UI. Used for internal configuration.

```yaml
- name: KeyPathGlob
  type: hidden
  default: InventoryApplicationFile\**
```

### redacted

Parameters masked in the UI (for credentials).

```yaml
- name: ApiKey
  type: redacted
  description: API key for authentication.
```

### upload

File upload parameter — the operator can upload a file when launching the artifact.

```yaml
- name: YaraRuleFile
  type: upload
  description: Upload a file containing YARA rules.
```

### json / json_array

Structured data parameters.

```yaml
- name: Parameters
  type: json
  default: "{}"
  description: Key/value parameters.

- name: FlowIds
  type: json_array
  default: "[]"
  description: List of flow IDs.
```

### yaml

YAML content parameter for configuration data.

```yaml
- name: CustomConfig
  type: yaml
  description: Custom configuration in YAML format.
```

### artifactset

Special type for selecting artifacts with their parameters.

```yaml
- name: ArtifactList
  type: artifactset
  artifact_type: CLIENT
  default: |
    Artifact
    Generic.Client.Info
```

---

## 4. VQL Language Reference

### Query Structure

```sql
-- Basic query
SELECT Column1, Column2 FROM plugin(arg1=value)

-- With WHERE filter
SELECT * FROM plugin() WHERE Column1 =~ 'pattern'

-- LET for named subqueries (lazy — re-evaluated each time referenced)
LET rows = SELECT OSPath FROM glob(globs=SomeGlob)

-- LET <= for materialized queries (evaluated once, cached in memory)
LET lookup <= dict(`key1`="value1", `key2`="value2")

-- LET function definition
LET MyFunc(Param1) = SELECT * FROM plugin(arg=Param1)
```

### Iteration with foreach()

VQL has **no JOIN**. Use `foreach()` to iterate rows and run a subquery for each:

```sql
-- Basic: iterate rows, run query for each
SELECT * FROM foreach(
  row={SELECT OSPath FROM glob(globs=SomeGlob)},
  query={SELECT * FROM read_file(filename=OSPath)}
)

-- With workers for parallel iteration
SELECT * FROM foreach(row=items, workers=20, query={...})

-- Async iteration for event sources (CLIENT_EVENT)
SELECT * FROM foreach(row=files, async=TRUE,
  query={SELECT * FROM watch_some_source(filename=OSPath)})
```

### Conditionals

```sql
-- if() as a function (returns a single value)
if(condition=Upload_File, then=upload(file=OSPath), else=NULL)

-- if() with nested conditions
if(condition=AddressFamily=23, then="IPv6",
   else=if(condition=AddressFamily=2, then="IPv4", else="Other"))

-- if() as a plugin (returns rows)
SELECT * FROM if(
  condition=YaraRule,
  then={SELECT * FROM yara(files=OSPath, rules=YaraRule)},
  else={SELECT * FROM some_other_query}
)

-- switch() — first non-empty result wins
SELECT * FROM switch(
  a={SELECT * FROM query1()},
  b={SELECT * FROM query2()},
  default={SELECT * FROM fallback()}
)

-- chain() — combine results from ALL queries
SELECT * FROM chain(
  a={SELECT * FROM query1()},
  b={SELECT * FROM query2()}
)
```

### File and Path Functions

| Function/Plugin | Usage | Example |
|-----------------|-------|---------|
| `glob(globs=, root=, accessor=, nosymlink=, recursion_callback=)` | Find files by pattern | `FROM glob(globs="/var/log/**")` |
| `read_file(filename=, accessor=, length=)` | Read file contents | `read_file(filename=OSPath, length=1024)` |
| `upload(file=, accessor=, name=, mtime=)` | Upload file to server | `upload(file=OSPath, name="evidence.bin")` |
| `hash(path=, accessor=)` | Calculate MD5/SHA1/SHA256 | `hash(path=OSPath, accessor="file")` |
| `stat(filename=, accessor=)` | Get file metadata | `stat(filename=OSPath)` |
| `tempfile(extension=)` | Create temporary file | `LET tmp <= tempfile(extension=".dat")` |
| `tempdir(remove_last=)` | Create temporary directory | `LET dir <= tempdir(remove_last=TRUE)` |
| `pathspec(parse=, DelegatePath=, Path=, DelegateAccessor=)` | Construct path specifications | `pathspec(DelegatePath=ZipPath)` |
| `expand(path=)` | Expand environment variables | `expand(path="%SystemRoot%\\System32")` |
| `basename(path=)` | Get filename from path | `basename(path=OSPath)` |
| `dirname(path=)` | Get directory from path | `dirname(path=OSPath)` |
| `copy(dest=, filename=, accessor=)` | Copy file | `copy(dest=tmpdir + "/out", filename=Src)` |

### String Functions

| Function | Usage | Example |
|----------|-------|---------|
| `split(string=, sep=)` | Split string by separator | `split(string=GlobList, sep=",")` |
| `join(array=, sep=)` | Join array to string | `join(array=Flags, sep=", ")` |
| `format(format=, args=)` | Printf-style formatting | `format(format="%#0x", args=Offset)` |
| `regex_replace(re=, replace=, source=)` | Regex substitution | `regex_replace(source=Line, re='\s+', replace=' ')` |
| `str(str=)` | Convert to string | `str(str=EventID.Value)` |
| `lowcase(string=)` | Lowercase string | `lowcase(string=Name)` |
| `upcase(string=)` | Uppercase string | `upcase(string=Drive)` |
| `len(list=)` | Length of string or array | `len(list=Data)` |
| `strip(string=, prefix=)` | Strip prefix from string | `strip(string=Id, prefix='000')` |
| `substr(str=, start=, end=)` | Extract substring | `substr(str=Name, start=0, end=5)` |
| `encode(string=, type=)` | Encode data (hex, base64) | `encode(string=Data, type="hex")` |
| `base64decode(string=)` | Base64 decode | `base64decode(string=EncodedStr)` |
| `base64encode(string=)` | Base64 encode | `base64encode(string=Data)` |
| `humanize(bytes=)` | Format bytes to human-readable | `humanize(bytes=Size)` |
| `atoi(string=)` | Parse integer from string | `atoi(string=Size)` |
| `atof(string=)` | Parse float from string | `atof(string=Value)` |
| `commandline_split(command=, bash_style=)` | Parse command-line arguments | `commandline_split(command=Line, bash_style=TRUE)` |
| `parse_string_with_regex(regex=, string=)` | Extract named groups | `parse_string_with_regex(regex="(?P<Name>[^/]+)", string=OSPath)` |
| `url(parse=)` | Parse URL components | `url(parse=ServerURL)` |

### Dict and Object Functions

| Function | Usage | Example |
|----------|-------|---------|
| `get(item=, member=, field=, default=)` | Safe field access | `get(item=Record, field="Desc", default="")` |
| `dict(key=val, ...)` | Create dictionary | `dict(Name=Name, Size=Size)` |
| `items(item=)` | Iterate dict as key-value pairs | `FROM items(item=Env)` — yields `_key`, `_value` |
| `set(item=, field=, value=)` | Set dict value | `set(item=dict(), field=Name, value=Data)` |
| `serialize(item=, format=)` | Serialize to JSON/YAML | `serialize(item=dict(text="msg"), format="json")` |
| `to_dict(item=)` | Convert rows to dict | `to_dict(item={SELECT Name, Data FROM ...})` |
| `memoize(key=, query=)` | Cache query results by key | `memoize(key="GUID", query={SELECT GUID, Name FROM ...})` |
| `enumerate(items=)` | Enumerate array items | `enumerate(items=ArrayField)` |
| `filter(list=, regex=)` | Filter array by regex | `filter(list=Items, regex=Pattern)` |
| `parse_json(data=)` | Parse JSON string | `parse_json(data=Content).result` |
| `parse_json_array(data=)` | Parse JSON array string | `FROM parse_json_array(data=Stdout)` |

### Time Functions

| Function | Usage | Example |
|----------|-------|---------|
| `timestamp(epoch=)` | Unix epoch (seconds) to timestamp | `timestamp(epoch=LastModified)` |
| `timestamp(winfiletime=)` | Windows FILETIME (100ns since 1601) | `timestamp(winfiletime=High * 4294967296 + Low)` |
| `timestamp(mactime=)` | Mac absolute time (seconds since 2001-01-01) | `timestamp(mactime=FileModDate)` |
| `timestamp(cocoatime=)` | Cocoa float64 timestamp | `timestamp(cocoatime=FloatValue)` |
| `timestamp(string=, format=)` | Parse timestamp string | `timestamp(string=Date, format="02-01-2006 15:04:05")` |
| `timestamp(epoch="1600-01-01")` | Create sentinel timestamp | Used for "no filter" date bounds |
| `now()` | Current time as epoch (seconds) | `now()` |

### Data Parsing Functions

| Function/Plugin | Usage | Example |
|-----------------|-------|---------|
| `parse_csv(filename=, accessor=)` | Parse CSV file | `FROM parse_csv(filename=CSVFile, accessor="data")` |
| `parse_lines(filename=, accessor=)` | Parse file line by line | `FROM parse_lines(filename=OSPath)` |
| `split_records(filenames=, regex=, columns=, first_row_is_headers=)` | Split file by delimiter | `FROM split_records(filenames="/etc/passwd", regex=":", columns=["User","X","Uid"])` |
| `parse_records_with_regex(file=, accessor=, regex=)` | Split file into regex-delimited records | `FROM parse_records_with_regex(file=Path, regex='(?sm)^(?P<Record>Package:.+?)\\n\\n')` |
| `parse_xml(file=, accessor=)` | Parse XML data | `parse_xml(accessor='data', file=XmlContent)` |
| `parse_binary(filename=, accessor=, profile=, struct=)` | Parse binary format with profile | `parse_binary(filename=Data, accessor="data", profile=Prof, struct="Header")` |
| `parse_jsonl(filename=, accessor=)` | Parse JSON lines file | `FROM parse_jsonl(filename=OSPath)` |
| `sqlite(file=, query=, accessor=)` | Query SQLite databases | `FROM sqlite(file=OSPath, query="SELECT * FROM urls")` |
| `grok(grok=, data=)` | Parse structured log with Grok patterns | `grok(grok=SSHGrok, data=Line)` |

### Control Flow Functions

| Function/Plugin | Usage | Example |
|-----------------|-------|---------|
| `foreach(row=, query=, workers=, async=)` | Iterate rows | `FROM foreach(row=files, workers=20, query={...})` |
| `if(condition=, then=, else=)` | Conditional | `if(condition=X, then=A, else=B)` |
| `switch(a=, b=, ..., default=)` | First non-empty branch | `FROM switch(a={...}, b={...}, default={...})` |
| `chain(a=, b=, ...)` | Combine all results | `FROM chain(a={...}, b={...})` |
| `scope()` | Access current scope | `FROM scope()` |
| `flatten(query=)` | Flatten nested results | `FROM flatten(query={SELECT LastRunTimes FROM scope()})` |
| `diff(query=, period=, key=)` | Detect changes over time | `FROM diff(query=reg_query, period=Period, key="FullPath")` |
| `fifo(query=, max_rows=, max_age=)` | Sliding window buffer | `FROM fifo(query=events, max_rows=500, max_age=Window)` |
| `delay(query=, delay=)` | Delay query start (seconds) | `FROM delay(query={...}, delay=3)` |
| `clock(period=, start=)` | Periodic timer | `FROM clock(period=ReloadPeriod)` |
| `atexit(query=)` | Cleanup on artifact exit | `LET _ <= atexit(query={SELECT cleanup() FROM scope()})` |
| `log(message=, args=, dedup=)` | Log message (returns TRUE) | `log(message="Processing %v", args=[OSPath], dedup=5)` |
| `alert(name=, ...)` | Send alert | `alert(name=AlertName, Key=OSPath)` |
| `sleep(time=)` | Pause execution | `FROM sleep(time=60)` |
| `count()` | Count results | `count()` |
| `range(to=, from=, step=)` | Generate integer range | `FROM range(to=10)` |

### Process Functions

| Function/Plugin | Usage | Example |
|-----------------|-------|---------|
| `pslist(pid=)` | List running processes | `FROM pslist()` |
| `getpid()` | Get current process PID | `WHERE Pid != getpid()` |
| `execve(argv=, length=, env=, cwd=)` | Execute external command | `FROM execve(argv=["ls", "-la"], length=10000000)` |
| `proc_yara(pid=, rules=)` | YARA scan process memory | `FROM proc_yara(pid=Pid, rules=YaraRule)` |
| `process_tracker_pslist()` | List tracked processes | `FROM process_tracker_pslist()` |
| `process_tracker_get(id=)` | Get process info by PID | `process_tracker_get(id=Pid).Data.Name` |
| `process_tracker_callchain(id=)` | Get process call chain | `join(array=process_tracker_callchain(id=Pid).Data.Name, sep=" -> ")` |
| `process_tracker_tree(id=)` | Get process tree | `process_tracker_tree(id=Pid)` |
| `connections()` | Enumerate network connections | `FROM connections()` |

### Network Functions

| Function | Usage | Example |
|----------|-------|---------|
| `http_client(url=, method=, headers=, data=, params=)` | HTTP request | `http_client(url=ApiURL, method="POST", data=Body)` |
| `ip(netaddr4_le=)` | Parse IP from little-endian integer | `ip(netaddr4_le=LocalAddrInt)` |
| `geoip(db=, ip=)` | GeoIP database lookup | `geoip(db=DBPath, ip=IPAddr).country.names.en` |
| `host(name=)` | DNS resolution | `host(name="example.com")` |

### Artifact Calling

```sql
-- Call another artifact and iterate its results
SELECT * FROM Artifact.Platform.Category.Name()

-- Call with parameters
SELECT * FROM Artifact.Generic.Utils.FetchBinary(ToolName="MyTool")

-- Import results from a named source
SELECT * FROM source(artifact="Linux.Debian.Packages", source="Snaps")
```

---

## 5. Accessor System

Accessors control how `glob()`, `read_file()`, `upload()`, and other file plugins access data.

### Shared Accessors (all platforms)

| Accessor | Purpose |
|----------|---------|
| `auto` | Standard file access (fastest, default) |
| `file` | Explicit file access |
| `data` | In-memory data — treat a string as file content |
| `scope` | Access variables in current scope |
| `process` | Process memory space |
| `zip` | ZIP archive contents |
| `sparse` | Sparse file regions (for memory dumps) |
| `gzip` | Gzip-compressed files |

### How Accessors Work

```sql
-- Read a file normally
read_file(filename=OSPath)
-- Equivalent: read_file(filename=OSPath, accessor="auto")

-- Treat a string as file content (parse in-memory data)
parse_json(data=Content)
-- For plugins that need accessor="data":
parse_csv(filename=CsvString, accessor="data")

-- Read inside a ZIP archive
read_file(filename=pathspec(DelegatePath=ZipPath, Path="/subdir/file.txt"),
          accessor="zip")

-- Glob inside a ZIP
FROM glob(globs="/**/*.yaml",
          root=pathspec(DelegatePath=ZipPath, DelegateAccessor="auto"),
          accessor="zip")
```

Platform-specific accessors (registry, ntfs, ntfs_vss, vss, raw_reg) are documented in windows.md.

---

## 6. Column Types Reference

The `column_types` section controls how the Velociraptor GUI renders specific columns.

```yaml
column_types:
  - name: ColumnName
    type: type_name
```

| Type | When to Use |
|------|------------|
| `timestamp` | Date/time values not auto-detected by the GUI |
| `preview_upload` | Uploaded file with preview capability |
| `tree` | Hierarchical/nested data (process trees) |
| `nobreak` | Long text that should not wrap in the GUI |
| `url` | Clickable URL rendering |
| `hex` | Hexadecimal display |
| `json` | Structured JSON data display |
| `json_array` | JSON array display |
| `mb` | Megabyte-formatted size |
| `hidden` | Hidden from default view |
| `base64hex` | Base64-encoded binary data |
| `upload_preview` | Uploaded file with preview (alternate form) |

**When NOT needed:** Columns returned by `timestamp()` or named with common timestamp patterns are auto-detected. Only declare `column_types` when the GUI does not render correctly by default.

---

## 7. Permissions Reference

```yaml
# Permissions the OPERATOR must have to launch this artifact
required_permissions:
  - EXECVE

# Permissions granted to the artifact ON the endpoint during execution
implied_permissions:
  - EXECVE
  - FILESYSTEM_WRITE
  - NETWORK
```

| Permission | Use When |
|-----------|----------|
| `EXECVE` (required) | Dangerous commands (netsh, auditctl, shell execution) |
| `EXECVE` (implied) | Safe read-only commands (systemctl, ipconfig, osquery) |
| `FILESYSTEM_WRITE` | Creates temp files, writes output (packet capture, memory dump) |
| `NETWORK` | Makes network connections or communicates via UNIX sockets |
| `MACHINE_STATE` | Modifies system state (server-side: deletes flows or events) |
| `SERVER_ADMIN` | Server-side admin operations (import artifacts, modify server config) |

**Rule of thumb:** If the command modifies system state or could be dangerous, use `required_permissions`. If it is read-only or harmless, use `implied_permissions`.

---

## 8. External Tool Integration

Use the `tools` section to declare external binaries. Velociraptor handles downloading, caching, and hash verification.

```yaml
# Pattern 1: GitHub releases with asset regex
tools:
  - name: OSQueryLinux
    github_project: Velocidex/OSQuery-Releases
    github_asset_regex: linux-amd64

# Pattern 2: Direct URL
tools:
  - name: SysmonBinary
    url: https://live.sysinternals.com/tools/sysmon64.exe
    serve_locally: true

# Pattern 3: URL with hash verification
tools:
  - name: MyTool
    url: https://example.com/tool
    expected_hash: abc123def456...
```

### Fetching and Using in VQL

```sql
-- Fetch binary path
LET binary <= SELECT OSPath
  FROM Artifact.Generic.Utils.FetchBinary(ToolName="OSQueryLinux")

-- Execute the tool
LET result = SELECT * FROM execve(
  argv=[binary[0].OSPath, "--json", Query],
  length=10000000)
```

### Architecture-Dependent Tool Selection

```sql
LET os_info <= SELECT Architecture FROM info()
LET bin <= SELECT * FROM Artifact.Generic.Utils.FetchBinary(
  ToolName="Autorun_" + os_info[0].Architecture)
```

### execve() Output Length

For commands that produce large output, always set `length=10000000`. The default may truncate output from package lists or system commands.

```sql
FROM execve(argv=["systemctl", "list-units"], length=10000000)
```

---

## 9. Common Pitfalls

### Bool Parameter Defaults

Always use `Y` or `N`, never `true`/`false`:

```yaml
- name: Upload_File
  type: bool
  default: N     # Correct
  # default: false  # WRONG — will not behave as expected
```

### Hidden Columns with _ Prefix

Prefix column aliases with `_` to hide from the default GUI view:

```sql
SELECT Name AS Visible, raw_data AS _RawData FROM ...
```

### Materialized vs Lazy Queries

```sql
LET rows = SELECT ...    -- Lazy: re-runs each time referenced
LET rows <= SELECT ...   -- Materialized: runs once, cached in memory

-- Use <= for:
--   Lookup tables, dict definitions, device major number lists
--   Expensive queries referenced multiple times
--   Results from Artifact calls (FetchBinary)
--   Credential lookups (server_metadata())

-- Use = for:
--   Queries that depend on outer scope variables (foreach row context)
--   Queries that should pick up changing state
```

### Parallel Source Execution

If **any** source has a `precondition`, ALL sources run in parallel with independent scopes:

- `LET` variables defined in one source are NOT visible in other sources.
- Artifact-level `export` blocks ARE shared across all sources.
- If you need shared state, use a single source or put shared VQL in the `export` block.

### No Trailing Semicolons

VQL statements do **not** end with `;`. Adding a semicolon causes a parse error.

### FROM scope() for LET Variables in Subqueries

When you need to access outer `LET` variables or `foreach()` row data inside a subquery:

```sql
LET details = SELECT get(member="fieldName") AS Field
FROM scope()   -- Required to access outer variables
```

### Safe Field Access with get()

Use `get()` to avoid errors when a field might not exist:

```sql
get(item=Record, field="Desc", default="")
get(member="EventData.TargetUserName", default="")
```

### Backtick Quoting for Special Field Names

Field names containing dashes, spaces, or starting with numbers require backtick quoting:

```sql
dict(`0x100`="value")
parse_json(data=Content).`key-with-dashes`
```

### log() for Debugging Without Flooding

Use `dedup=N` to emit a log message at most once every N occurrences:

```sql
WHERE log(message="Processing %v", args=[OSPath], dedup=5)
```

`log()` returns TRUE, so it can be used in a WHERE clause without filtering rows.

### Glob Parameter Formats

Match the VQL consumption to the parameter format:

```sql
-- Comma-separated string → use split()
FROM glob(globs=split(string=GlobParam, sep=","))

-- JSON array string → use parse_json_array()
FROM glob(globs=parse_json_array(data=GlobParam))

-- CSV table column → access column by name directly
FROM glob(globs=SearchFilesGlobTable.Glob)

-- Single path string → use directly
FROM glob(globs=SingleGlobParam)
```

### Timestamp Parameter Handling

For optional date filters, use empty string as default and sentinel values in VQL:

```sql
-- Empty default = no filter
# default: ""

-- Guard with sentinel values:
LET DateAfterTime <= if(condition=DateAfter,
  then=DateAfter, else=timestamp(epoch="1600-01-01"))
```

---

## 10. Artifact Development Checklist

Before finalizing a new artifact:

1. **Name matches path:** `Linux.Sys.Foo` → `artifacts/definitions/Linux/Sys/Foo.yaml`
2. **Type field present:** Include `type: CLIENT` (or CLIENT_EVENT for monitoring) explicitly
3. **Precondition correct:** Artifact-level `OS =~ 'platform'` unless source-level needed; server artifacts have no OS precondition
4. **Description starts with summary:** First line is a complete sentence describing what the artifact does
5. **All parameters have defaults:** Every parameter has a sensible `default` value
6. **Glob consumption matches format:** `split()` for comma-separated, `parse_json_array()` for JSON arrays, `.Column` for CSV tables, direct for single paths
7. **Timestamps converted:** All epoch values wrapped in `timestamp()`; use appropriate epoch type (mactime, cocoatime, winfiletime as needed)
8. **Hidden columns prefixed:** Internal/raw columns use `_` prefix
9. **column_types declared:** Non-obvious timestamp, upload, tree, or nobreak columns have explicit types
10. **Permissions set:** `required_permissions` or `implied_permissions` if using `execve()`, writing files, or making network connections
11. **No trailing semicolons:** VQL statements do NOT end with `;`
12. **Author attributed:** Include `author:` field with name and handle
13. **execve() length set:** Include `length=10000000` when using `execve()` for large output
14. **Bool defaults are Y/N:** Never use `true`/`false` as bool defaults
15. **No platform-specific content in wrong guide:** Check the overlay for platform-specific paths, functions, and patterns

---

## 11. Tool Integration Patterns

### CLI Commands

```bash
# Start a local server for development
velociraptor gui

# Run a VQL query from the command line
velociraptor query "SELECT * FROM info()"

# Test an artifact definition without a server
velociraptor artifacts collect -v ArtifactName

# Repack the Velociraptor binary with a new config
velociraptor config repack --exe /path/to/velociraptor

# Generate an API client config (for remote access)
velociraptor --config server.config.yaml config api_client --name analyst > api.config.yaml

# Pack a collection of artifacts into a ZIP
velociraptor artifacts pack ArtifactName --output /tmp/collection.zip
```

### Server API Client (for automation)

Once an API client config exists:

```bash
# Execute a server artifact via API
velociraptor --api_config api.config.yaml query "SELECT * FROM hunt_results(hunt_id='H.XXXXXX')"
```

---

## 12. Template Selection Guide

Choose the template that best matches your artifact's primary operation:

### Common Templates (templates/common/)

| Use Case | Template | When to Use |
|----------|----------|-------------|
| Generic CLIENT artifact scaffold | `base-client-artifact.yaml` | Starting point for any new client artifact |
| Generic SERVER artifact scaffold | `base-server-artifact.yaml` | Starting point for any new server artifact |
| All parameter types demonstrated | `parameterized-artifact.yaml` | Reference for parameter configuration |
| File search → filter → YARA → hash → upload | `file-search-enrichment.yaml` | Cross-platform file hunting with enrichment |
| External command → parse output | `system-command.yaml` | Running tools via execve() on any platform |
| pslist/YARA process scanning | `process-detection.yaml` | Process-based threat detection |
| chain() + named sources | `multi-source-detection.yaml` | Combining multiple detection sources |

### Windows Templates (templates/windows/)

| Use Case | Template |
|----------|----------|
| Registry key enumeration | `registry-query.yaml` |
| EVTX event log parsing | `eventlog-query.yaml` |
| WMI/CIM queries | `wmi-query.yaml` |
| ETW real-time monitoring | `etw-monitoring.yaml` |
| NTFS/MFT forensics | `ntfs-forensics.yaml` |
| Sigma rule evaluation | `sigma-rule.yaml` |

### macOS Templates (templates/macos/)

| Use Case | Template |
|----------|----------|
| Plist config/preference parsing | `glob-plist.yaml` |
| SQLite database querying | `glob-sqlite.yaml` |
| Custom binary format parsing | `binary-format-parsing.yaml` |

### Linux Templates (templates/linux/)

| Use Case | Template |
|----------|----------|
| Syslog/journald log parsing | `syslog-journal.yaml` |
| /proc filesystem parsing | `proc-filesystem.yaml` |
| eBPF real-time event monitoring | `ebpf-monitoring.yaml` |
| Package manager queries | `package-query.yaml` |
| Text config file parsing (/etc/*) | `config-file-parsing.yaml` |
| SSH key and config analysis | `ssh-security.yaml` |
| Network connection enumeration | `network-connections.yaml` |

### Server Templates (templates/server/)

| Use Case | Template |
|----------|----------|
| Watch event streams | `event-monitoring.yaml` |
| Slack/Teams/Discord/TheHive alerts | `alert-webhook.yaml` |
| Schedule artifact collection on clients | `client-collection.yaml` |
| Hunt creation and management | `hunt-management.yaml` |
| External API enrichment | `enrichment-api.yaml` |
| Periodic scheduled tasks (clock-based) | `scheduled-task.yaml` |
| Query client/flow data on server | `client-query.yaml` |
| Label-based client targeting | `label-automation.yaml` |

### Decision Tree

1. Is this a server-side artifact? → See server.md and server templates
2. Does it search for files with optional hash/YARA/upload? → `file-search-enrichment.yaml`
3. Does it run an external command and parse output? → `system-command.yaml`
4. Does it scan running processes with YARA? → `process-detection.yaml`
5. Does it collect from multiple independent sources? → `multi-source-detection.yaml`
6. Platform-specific? → Read the relevant overlay and choose a platform template

---

*Platform-specific content (registry, EVTX, ETW, WMI, NTFS on Windows; plist, TCC, mactime on macOS; journald, eBPF, /proc on Linux; hunt management, webhooks, scheduling on Server) is in the overlay guides.*
